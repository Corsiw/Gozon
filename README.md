# Gozon — Асинхронное межсервисное взаимодействие (Orders & Payments)

Автор: Терехов Дмитрий.

Данный проект реализует упрощённую модель интернет-магазина «Гоzон»  
с акцентом на **корректную архитектуру микросервисов**,  
**гарантии доставки сообщений** и **консистентность финансовых операций**  
в условиях высокой нагрузки.

---

## 1. Общая архитектура

Система состоит из следующих компонентов:

- **API Gateway**
    - Единственная точка входа для frontend
    - Выполняет routing запросов к микросервисам

- **Orders Service**
    - Создание заказов
    - Просмотр списка заказов
    - Просмотр статуса отдельного заказа
    - Использует **Transactional Outbox** для публикации событий

- **Payments Service**
    - Создание банковского счёта
    - Пополнение счёта
    - Просмотр баланса
    - Асинхронная обработка оплаты заказа
    - Использует **Transactional Inbox + Outbox**
    - Обеспечивает семантику **effectively exactly-once**

- **Apache Kafka**
    - Асинхронное взаимодействие между сервисами
    - Гарантия доставки сообщений at-least-once

- **Frontend (React + Nginx)**
    - Минимальный UI для тестирования REST API
    - Все запросы идут через API Gateway

---

## 2. Ключевые особенности реализации

### 2.1 Асинхронное взаимодействие

- Создание заказа **не блокирует пользователя**
- Оплата запускается асинхронно через Kafka

### 2.2 Transactional Outbox

- В `Orders Service` события сохраняются в таблицу Outbox
- Событие и заказ сохраняются **в одной транзакции**
- Отдельный background worker публикует события в Kafka

### 2.3 Transactional Inbox

- В `Payments Service` все входящие сообщения сохраняются в Inbox
- Каждое сообщение обрабатывается **строго один раз**
- Повторные сообщения игнорируются

### 2.4 Exactly-once при списании денег

- Используется **идемпотентная обработка**
- Каждому заказу соответствует ровно одно списание
- Повторные события не приводят к повторному списанию

### 2.5 Консистентность банковского счёта

- Используется **Optimistic Concurrency Control (Compare-And-Swap)**
- EF Core `ConcurrencyToken (Version)`
- Retry-механизм на уровне Application layer
- Отсутствие блокировок (`lock` не используется)

### 2.6 Clean Architecture + DDD

- Domain слой не знает о Kafka, EF Core и HTTP
- Application слой реализует use-cases
- Infrastructure слой отвечает за:
    - Kafka
    - EF Core
    - Inbox / Outbox
- Исключения домена и приложения не зависят от HTTP

---

## 3. Соответствие требованиям ТЗ

| Требование ТЗ           | Реализация                       |
|-------------------------|----------------------------------|
| Разделение сервисов     | Orders / Payments                |
| Асинхронная оплата      | Kafka                            |
| At-least-once доставка  | Kafka                            |
| Exactly-once списание   | Inbox + idempotency              |
| Transactional Outbox    | Orders Service, Payments Service |
| Transactional Inbox     | Payments Service                 |
| Консистентность баланса | CAS (optimistic concurrency)     |
| REST API                | ASP.NET Core Minimal API         |
| Docker Compose          | Полный стек разворачивается      |

---

## 4. Работа с системой

### 4.1 Работа через Frontend

Frontend доступен по адресу:

[http://localhost:5173](http://localhost:5173)

Через UI можно:

**Payments**

- Создать банковский счёт
- Пополнить баланс
- Посмотреть баланс

**Orders**

- Создать заказ
- Посмотреть список заказов
- Получить заказ по `orderId`

Все запросы автоматически отправляются:

- через API Gateway
- с заголовком `X-User-Id`

---

### 4.2 Работа через Swagger

Swagger доступен для каждого сервиса:

- Gateway:

[http://localhost:8080/swagger](http://localhost:8080/swagger)

> Если GATEWAY_PORT=8080 в .env

В Swagger:

- `X-User-Id` передаётся через HTTP header
- Все сценарии ТЗ доступны через REST

---

## 5. Передача UserId

Во всех запросах используется заголовок:

`X-User-Id: <GUID>`

Это имитирует работу API Gateway / системы аутентификации  
и позволяет не передавать `userId` в теле запросов.

---

## 6. Сборка и запуск проекта

### 6.1 Требования

- Docker
- Docker Compose
- Свободные порты:
    - 5173 (frontend)
    - 8080 (gateway)
    - Kafka / Zookeeper

---

### 6.2 Сборка и запуск

В корне проекта выполнить:

```bash
  docker compose up --build
````

Будут подняты:

* Frontend (React + Nginx)
* API Gateway
* Orders Service
* Payments Service
* Kafka
* Zookeeper

---

### 6.3 Проверка работоспособности

1. Открыть Frontend:

   ```
   http://localhost:5173
   ```

2. Создать банковский счёт

3. Пополнить баланс

4. Создать заказ

5. Проверить, что:

    * заказ создаётся сразу
    * оплата проходит асинхронно
    * статус заказа обновляется

---

## 7. Итог

Данный проект демонстрирует:

* корректное асинхронное взаимодействие микросервисов
* применение паттернов Inbox / Outbox
* консистентную работу с денежными средствами
* чистую архитектуру, готовую к масштабированию

Проект ориентирован на **архитектурную корректность**,
а не на UI или продуктовую полноту.

---
